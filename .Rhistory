cat("\n⚠️  Metrics are equal because FP = FN:\n")
cat(sprintf("   TP = %d, FP = %d, FN = %d\n", x$total_tp, x$total_fp, x$total_fn))
cat(sprintf("   Precision = %d/(%d+%d) = %.4f\n",
x$total_tp, x$total_tp, x$total_fp, x$overall_precision))
cat(sprintf("   Recall = %d/(%d+%d) = %.4f\n",
x$total_tp, x$total_tp, x$total_fn, x$overall_recall))
cat(sprintf("   Accuracy = %d/(%d+%d+%d) = %.4f\n",
x$total_tp, x$total_tp, x$total_fp, x$total_fn, x$accuracy))
}
}
validation <- validate_TTS(tts, trees_filtered@data, val_field = "treeid")
print.TTS_validation(validation)
#' @return List containing validation metrics
#' @export
#' Validate Segmentation Quality with Comprehensive Metrics
#'
#' @param TTS_result Result from TTS_segmentation()
#' @param lasdf Input point cloud in las/laz or matrix format
#' @param val_field Column name containing ground truth tree labels in lasdf (default: "treeID")
#'
#' @return List containing validation metrics
#' @export
validate_TTS <- function(TTS_result, lasdf, val_field = "treeID") {
message("=== TopTreeSegR VALIDATION ===\n")
# Extract data
if (inherits(lasdf, "LAS")) {
las_data = lasdf@data
} else if (is.data.frame(lasdf) || is.matrix(lasdf)) {
las_data = as.data.frame(lasdf)
} else {
stop("lasdf must be a LAS object, data frame, or matrix")
}
# Get segmentation and point IDs
segmentation = TTS_result$segmentation
point_ids = TTS_result$input_truth  # pid values
id_column = TTS_result$input_truth_column  # Column name containing pid (e.g., "pid")
message("Segmentation length: ", length(segmentation), "\n")
message("Point IDs length: ", length(point_ids), "\n")
message("ID column: ", ifelse(is.null(id_column), "None", id_column), "\n")
message("Tree label column: '", val_field, "'\n")
# ===== CORRECT: JOIN BY PID, PRESERVING ORDER =====
# 1. Create data frame with segmentation results
seg_df = data.frame(
pid = point_ids,
segmentation = segmentation,
order_idx = 1:length(segmentation)  # Preserve original order
)
# 2. Extract needed columns from las_data
if (is.null(id_column) || !id_column %in% colnames(las_data)) {
stop(sprintf("ID column '%s' not found in lasdf", id_column))
}
if (!val_field %in% colnames(las_data)) {
stop(sprintf("Tree label column '%s' not found in lasdf", val_field))
}
truth_df = data.frame(
pid = las_data[[id_column]],
ground_truth = las_data[[val_field]]
)
# 3. Merge/join by pid, keeping segmentation order
merged_df = merge(seg_df, truth_df, by = "pid", all.x = TRUE, sort = FALSE)
# 4. Sort back to original segmentation order
merged_df = merged_df[order(merged_df$order_idx), ]
# 5. Extract aligned vectors
segmentation_aligned = merged_df$segmentation
ground_truth_aligned = merged_df$ground_truth
pid_aligned = merged_df$pid
# Check for missing matches
missing_truth = is.na(ground_truth_aligned)
if (any(missing_truth)) {
message("WARNING: ", sum(missing_truth), " points (",
round(mean(missing_truth)*100, 1), "%) have no ground truth\n")
}
# Remove points without ground truth
valid_idx = !missing_truth
segmentation = segmentation_aligned[valid_idx]
ground_truth = ground_truth_aligned[valid_idx]
pid = pid_aligned[valid_idx]
message("Points with ground truth: ", sum(valid_idx), "/",
length(segmentation_aligned), " (",
round(mean(valid_idx)*100, 1), "%)\n")
# Remove unassigned points (segmentation == 0)
assigned_idx = segmentation > 0
segmentation = segmentation[assigned_idx]
ground_truth = ground_truth[assigned_idx]
pid = pid[assigned_idx]
message("Assigned points with ground truth: ", sum(assigned_idx), "\n")
# Basic info
n_trees = length(unique(segmentation))
n_gt_trees = length(unique(ground_truth))
message(sprintf("Detected trees: %d\n", n_trees))
message(sprintf("Ground truth trees: %d\n", n_gt_trees))
if (n_trees == 0 || n_gt_trees == 0) {
warning("No trees to evaluate.")
return(list(
n_trees = n_trees,
n_gt_trees = n_gt_trees,
n_points = length(segmentation)
))
}
# ===== DATA VERIFICATION =====
message("\n=== DATA VERIFICATION ===\n")
# Verify alignment
message("Checking alignment...\n")
message("First 10 PIDs in segmentation: ", paste(head(pid, 10), collapse=", "), "\n")
message("First 10 segmentation values: ", paste(head(segmentation, 10), collapse=", "), "\n")
message("First 10 ground truth values: ", paste(head(ground_truth, 10), collapse=", "), "\n")
# Check for duplicates
if (any(duplicated(pid))) {
warning("Duplicate PIDs found! This may indicate a problem.\n")
}
# ===== COMPUTE METRICS =====
# 1. Confusion matrix
conf_matrix = table(Predicted = segmentation, Actual = ground_truth)
message("\nConfusion matrix: ", nrow(conf_matrix), " × ", ncol(conf_matrix), "\n")
message("Total points in matrix: ", sum(conf_matrix), "\n")
# 2. One-to-one matching metrics
metrics_df = data.frame()
for (pred_id in rownames(conf_matrix)) {
pred_mask = segmentation == as.numeric(pred_id)
gt_counts = table(ground_truth[pred_mask])
if (length(gt_counts) > 0) {
best_gt = names(which.max(gt_counts))
tp = max(gt_counts)
fp = sum(pred_mask) - tp
fn = sum(ground_truth == as.numeric(best_gt)) - tp
precision = ifelse(tp + fp > 0, tp / (tp + fp), 0)
recall = ifelse(tp + fn > 0, tp / (tp + fn), 0)
f1 = ifelse(precision + recall > 0, 2 * precision * recall / (precision + recall), 0)
metrics_df = rbind(metrics_df, data.frame(
Predicted = as.numeric(pred_id),
Best_GT = as.numeric(best_gt),
N_Points = sum(pred_mask),
TP = tp,
FP = fp,
FN = fn,
Precision = precision,
Recall = recall,
F1 = f1,
Overlap_Ratio = tp / sum(pred_mask)
))
}
}
# 3. Calculate overall tree-level metrics
# Create matched pairs
matched_pairs = unique(metrics_df[, c("Predicted", "Best_GT")])
# Calculate totals correctly
total_tp = 0
total_fp = 0
total_fn = 0
# For each matched pair
for (i in 1:nrow(matched_pairs)) {
pred = as.character(matched_pairs$Predicted[i])
gt = as.character(matched_pairs$Best_GT[i])
if (pred %in% rownames(conf_matrix) && gt %in% colnames(conf_matrix)) {
tp = conf_matrix[pred, gt]
total_tp = total_tp + tp
# FP: other points in this predicted tree
total_fp = total_fp + (sum(conf_matrix[pred, ]) - tp)
# FN: other points in this ground truth tree
total_fn = total_fn + (sum(conf_matrix[, gt]) - tp)
}
}
# Handle unmatched predicted trees (all points are FP)
all_pred = rownames(conf_matrix)
matched_pred = as.character(matched_pairs$Predicted)
unmatched_pred = setdiff(all_pred, matched_pred)
for (pred in unmatched_pred) {
total_fp = total_fp + sum(conf_matrix[pred, ])
}
# Handle unmatched ground truth trees (all points are FN)
all_gt = colnames(conf_matrix)
matched_gt = as.character(matched_pairs$Best_GT)
unmatched_gt = setdiff(all_gt, matched_gt)
for (gt in unmatched_gt) {
total_fn = total_fn + sum(conf_matrix[, gt])
}
# Calculate overall metrics
overall_precision = ifelse(total_tp + total_fp > 0, total_tp / (total_tp + total_fp), 0)
overall_recall = ifelse(total_tp + total_fn > 0, total_tp / (total_tp + total_fn), 0)
overall_f1 = ifelse(overall_precision + overall_recall > 0,
2 * overall_precision * overall_recall / (overall_precision + overall_recall), 0)
# 4. Point-level accuracy (different from tree-level!)
accuracy = sum(diag(conf_matrix)) / sum(conf_matrix)
# 5. Rand Indices
if (requireNamespace("mclust", quietly = TRUE)) {
ari = mclust::adjustedRandIndex(segmentation, ground_truth)
# Calculate RI
n = length(segmentation)
sum_rows = rowSums(conf_matrix)
sum_cols = colSums(conf_matrix)
sum_comb_rows = sum(choose(sum_rows, 2))
sum_comb_cols = sum(choose(sum_cols, 2))
sum_comb_cells = sum(choose(conf_matrix, 2))
total_comb = choose(n, 2)
ri = (sum_comb_cells + (total_comb - sum_comb_rows - sum_comb_cols + sum_comb_cells)) / total_comb
} else {
ri = NA
ari = NA
warning("Install 'mclust' for Rand Index calculations")
}
# 6. Print results
message("\n=== METRICS ===\n")
message(sprintf("Tree-level Precision:  %.4f\n", overall_precision))
message(sprintf("Tree-level Recall:     %.4f\n", overall_recall))
message(sprintf("Tree-level F1:         %.4f\n", overall_f1))
message(sprintf("Point-level Accuracy:  %.4f\n", accuracy))
message(sprintf("Rand Index:            %.4f\n", ri))
message(sprintf("Adj. Rand Index:       %.4f\n", ari))
# Explain if metrics are equal
if (abs(overall_precision - overall_recall) < 0.0001 &&
abs(overall_precision - accuracy) < 0.0001) {
message(sprintf("\nNOTE: All metrics = %.4f because:\n", overall_precision))
message(sprintf("  TP = %d, FP = %d, FN = %d\n", total_tp, total_fp, total_fn))
message(sprintf("  Precision = TP/(TP+FP) = %d/(%d+%d)\n", total_tp, total_tp, total_fp))
message(sprintf("  Recall = TP/(TP+FN) = %d/(%d+%d)\n", total_tp, total_tp, total_fn))
message(sprintf("  Accuracy = TP/(TP+FP+FN) = %d/(%d+%d+%d)\n",
total_tp, total_tp, total_fp, total_fn))
if (total_fp == total_fn) {
message("  Since FP = FN, Precision = Recall = Accuracy\n")
}
}
# Return results
result = list(
n_trees = n_trees,
n_gt_trees = n_gt_trees,
n_points = length(segmentation),
n_points_original = length(TTS_result$segmentation),
matched_points_ratio = length(segmentation) / length(TTS_result$segmentation),
overall_precision = overall_precision,
overall_recall = overall_recall,
overall_f1 = overall_f1,
accuracy = accuracy,
rand_index = ri,
adjusted_rand_index = ari,
total_tp = total_tp,
total_fp = total_fp,
total_fn = total_fn,
matched_pairs = matched_pairs,
unmatched_predicted = unmatched_pred,
unmatched_ground_truth = unmatched_gt,
per_tree_metrics = metrics_df,
confusion_matrix = conf_matrix,
# Return aligned data for debugging
segmentation_aligned = segmentation,
ground_truth_aligned = ground_truth,
pid_aligned = pid
)
class(result) = "TTS_validation"
return(result)
}
#' Print Method for TTS_result
#'
#' @param x validate_TTS object
#' @param ... Additional parameters
#'
#' @export
#' @method print TTS_result
# Print method for validation results
print.TTS_validation <- function(x, ...) {
cat("=== TTS Validation Results ===\n\n")
cat(sprintf("Points: %d/%d (%.1f%% matched)\n",
x$n_points, x$n_points_original, x$matched_points_ratio*100))
cat(sprintf("Trees: %d detected, %d ground truth\n", x$n_trees, x$n_gt_trees))
cat("\n--- Performance Metrics ---\n")
cat(sprintf("Precision (tree):  %.4f\n", x$overall_precision))
cat(sprintf("Recall (tree):     %.4f\n", x$overall_recall))
cat(sprintf("F1-Score (tree):   %.4f\n", x$overall_f1))
cat(sprintf("Accuracy (point):  %.4f\n", x$accuracy))
if (!is.na(x$rand_index)) {
cat(sprintf("Rand Index:        %.4f\n", x$rand_index))
}
if (!is.na(x$adjusted_rand_index)) {
cat(sprintf("Adj. Rand Index:   %.4f\n", x$adjusted_rand_index))
}
# Show per-tree summary
if (!is.null(x$per_tree_metrics) && nrow(x$per_tree_metrics) > 0) {
cat("\n--- Tree Matching Summary ---\n")
cat(sprintf("Matched pairs: %d\n", nrow(x$matched_pairs)))
cat(sprintf("Unmatched predicted trees: %d\n", length(x$unmatched_predicted)))
cat(sprintf("Unmatched ground truth trees: %d\n", length(x$unmatched_ground_truth)))
}
}
validation <- validate_TTS(tts, trees_filtered@data, val_field = "treeid")
print.TTS_validation(validation)
#' Validate Segmentation Quality with Comprehensive Metrics
#'
#' @param TTS_result Result from TTS_segmentation()
#' @param lasdf Input point cloud in las/laz or matrix format
#' @param val_field Column name containing ground truth tree labels in lasdf (default: "treeID")
#'
#' @return List containing validation metrics
#' @export
validate_TTS <- function(TTS_result, lasdf, val_field = "treeID") {
message("=== TopTreeSegR VALIDATION ===\n")
# Extract data
if (inherits(lasdf, "LAS")) {
las_data = lasdf@data
} else if (is.data.frame(lasdf) || is.matrix(lasdf)) {
las_data = as.data.frame(lasdf)
} else {
stop("lasdf must be a LAS object, data frame, or matrix")
}
# Get segmentation and point IDs
segmentation = TTS_result$segmentation
pid = TTS_result$input_truth
id_column = TTS_result$input_truth_column
message("Segmentation length: ", length(segmentation))
message("PID length: ", length(pid))
message("PID column: ", ifelse(is.null(id_column), "None", id_column))
# Check columns
if (!id_column %in% colnames(las_data)) {
stop(sprintf("PID column '%s' not found in lasdf", id_column))
}
if (!val_field %in% colnames(las_data)) {
stop(sprintf("Tree label column '%s' not found in lasdf", val_field))
}
# Simple lookup: pid -> ground_truth
truth_lookup = setNames(las_data[[val_field]], las_data[[id_column]])
ground_truth = truth_lookup[as.character(pid)]
# Remove NA and unassigned points
keep = !is.na(ground_truth) & segmentation > 0
segmentation = segmentation[keep]
ground_truth = ground_truth[keep]
pid = pid[keep]
message("Points for evaluation: ", length(segmentation))
message("Detected trees: ", length(unique(segmentation)))
message("Ground truth trees: ", length(unique(ground_truth)))
if (length(segmentation) == 0) {
warning("No points to evaluate.")
return(list(n_points = 0))
}
# ===== COMPUTE METRICS =====
# Confusion matrix
conf_matrix = table(Predicted = segmentation, Actual = ground_truth)
# One-to-one matching metrics
metrics_df = data.frame()
total_tp = total_fp = total_fn = 0
for (pred_id in rownames(conf_matrix)) {
pred_mask = segmentation == as.numeric(pred_id)
gt_counts = table(ground_truth[pred_mask])
if (length(gt_counts) > 0) {
best_gt = names(which.max(gt_counts))
tp = max(gt_counts)
fp = sum(pred_mask) - tp
fn = sum(ground_truth == as.numeric(best_gt)) - tp
total_tp = total_tp + tp
total_fp = total_fp + fp
total_fn = total_fn + fn
precision = ifelse(tp + fp > 0, tp / (tp + fp), 0)
recall = ifelse(tp + fn > 0, tp / (tp + fn), 0)
f1 = ifelse(precision + recall > 0, 2 * precision * recall / (precision + recall), 0)
metrics_df = rbind(metrics_df, data.frame(
Predicted = as.numeric(pred_id),
Best_GT = as.numeric(best_gt),
TP = tp, FP = fp, FN = fn,
Precision = precision, Recall = recall, F1 = f1
))
}
}
# Overall metrics
overall_precision = ifelse(total_tp + total_fp > 0, total_tp / (total_tp + total_fp), 0)
overall_recall = ifelse(total_tp + total_fn > 0, total_tp / (total_tp + total_fn), 0)
overall_f1 = ifelse(overall_precision + overall_recall > 0,
2 * overall_precision * overall_recall / (overall_precision + overall_recall), 0)
# Accuracy
accuracy = sum(diag(conf_matrix)) / sum(conf_matrix)
# Rand Indices
if (requireNamespace("mclust", quietly = TRUE)) {
ari = mclust::adjustedRandIndex(segmentation, ground_truth)
# Calculate RI
n = length(segmentation)
sum_rows = rowSums(conf_matrix)
sum_cols = colSums(conf_matrix)
sum_comb_rows = sum(choose(sum_rows, 2))
sum_comb_cols = sum(choose(sum_cols, 2))
sum_comb_cells = sum(choose(conf_matrix, 2))
total_comb = choose(n, 2)
ri = (sum_comb_cells + (total_comb - sum_comb_rows - sum_comb_cols + sum_comb_cells)) / total_comb
} else {
ri = NA
ari = NA
}
# Print results
message("\n=== METRICS ===")
message(sprintf("Precision:  %.4f", overall_precision))
message(sprintf("Recall:     %.4f", overall_recall))
message(sprintf("F1-Score:   %.4f", overall_f1))
message(sprintf("Accuracy:   %.4f", accuracy))
if (!is.na(ri)) message(sprintf("Rand Index: %.4f", ri))
if (!is.na(ari)) message(sprintf("Adj Rand:   %.4f", ari))
# Return results
result = list(
n_trees = length(unique(segmentation)),
n_gt_trees = length(unique(ground_truth)),
n_points = length(segmentation),
overall_precision = overall_precision,
overall_recall = overall_recall,
overall_f1 = overall_f1,
accuracy = accuracy,
rand_index = ri,
adjusted_rand_index = ari,
per_tree_metrics = metrics_df,
confusion_matrix = conf_matrix
)
class(result) = "TTS_validation"
return(result)
}
#' Print Method for TTS_result
#'
#' @param x validate_TTS object
#' @param ... Additional parameters
#'
#' @export
#' @method print TTS_result
# Print method for validation results
print.TTS_validation <- function(x, ...) {
cat("TTS Validation Results:\n")
cat(sprintf("Trees: %d detected, %d ground truth\n", x$n_trees, x$n_gt_trees))
cat(sprintf("Points: %d\n", x$n_points))
cat(sprintf("Precision:  %.4f\n", x$overall_precision))
cat(sprintf("Recall:     %.4f\n", x$overall_recall))
cat(sprintf("F1-Score:   %.4f\n", x$overall_f1))
cat(sprintf("Accuracy:   %.4f\n", x$accuracy))
if (!is.na(x$rand_index)) cat(sprintf("Rand Index: %.4f\n", x$rand_index))
if (!is.na(x$adjusted_rand_index)) cat(sprintf("Adj Rand:  %.4f\n", x$adjusted_rand_index))
}
print.TTS_validation(validate_TTS(tts, trees_filtered@data, val_field = "treeid"))
validation <- validate_TTS(tts, trees_filtered@data, val_field = "treeid")
print.TTS_validation(validation)
# ----- TopTreeSegR -----
tts <- TTS_segmentation(
lasdf = trees_filtered,
alpha = .1,           # Alpha-complex parameter
input_truth = "pid",
clip_height = .5,     # Max stem detection height
max_distance = 2,   # Minima connectivity
cores = 3            # Parallel processing
)
plot_TTS_3d(tts)
validation <- validate_TTS(tts, trees_filtered@data, val_field = "treeid")
# ----- TopTreeSegR -----
tts <- TTS_segmentation(
lasdf = trees_filtered,
alpha = .05,           # Alpha-complex parameter
input_truth = "pid",
clip_height = .5,     # Max stem detection height
max_distance = .5,     # Minima connectivity
cores = 3             # Parallel processing
)
# ----- TopTreeSegR -----
tts <- TTS_segmentation(
lasdf = trees_filtered,
alpha = .1,           # Alpha-complex parameter
input_truth = "pid",
clip_height = .5,      # Max stem detection height
max_distance = 1,     # Minima connectivity
grid_size = 3.0,
cores = 3              # Parallel processing
)
validation <- validate_TTS(tts, trees_filtered@data, val_field = "treeid")
plot_TTS_3d(tts)
# Import packs
library(lidR)
library(dplyr)
# Read LAS file
trees <- readLAS("D:/xxx/lasref/12tree_exampleN.las")
trees_filtered <- filter_poi(trees, treeid %in% c(1,8,9,11,12))
trees_filtered$treeid <- case_when(
trees_filtered$treeid == 1 ~ 1L,
trees_filtered$treeid == 8 ~ 2L,
trees_filtered$treeid == 9 ~ 3L,
trees_filtered$treeid == 11 ~ 4L,
trees_filtered$treeid == 12 ~ 5L,
TRUE ~ trees_filtered$treeid
)
pid <- 1:npoints(trees_filtered)  # Use npoints() instead of nrow() for LAS objects
trees_filtered <- add_lasattribute(trees_filtered, pid, "pid", "Unique point ID")
source("D:/TopTreeSegR/R/TopTreeSegR.R")
##
Rcpp::sourceCpp("D:/TopTreeSegR/src/TopTreeSegR_GradientFlow.cpp")
# ----- TopTreeSegR -----
tts <- TTS_segmentation(
lasdf = trees_filtered,
alpha = .1,           # Alpha-complex parameter
input_truth = "pid",
clip_height = .5,     # Max stem detection height
max_distance = 2,     # Minima connectivity
grid_size = 5.0,      # Grid size for spatial hashing
cores = 3             # Parallel processing
)
source("D:/TopTreeSegR/R/TopTreeSegR.R")
# ----- TopTreeSegR -----
tts <- TTS_segmentation(
lasdf = trees_filtered,
alpha = .1,           # Alpha-complex parameter
input_truth = "pid",
clip_height = .5,     # Max stem detection height
max_distance = 2,     # Minima connectivity
grid_size = 5.0,      # Grid size for spatial hashing
cores = 3             # Parallel processing
)
plot_TTS_3d(tts)
validation <- validate_TTS(tts, trees_filtered@data, val_field = "treeid")
ahull3D::ahull3d
ahull3D::ahull3D
DiscreteMorseR::get_CCMESH
DiscreteMorseR::compute_MORSE_complex
DiscreteMorseR::get_SIMPLICES
ahull3D::ahull3D
ahull3D::ahull3D
iscreteMorseR::get_CCMESH
DiscreteMorseR::get_CCMESH
